<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    code, pre{
        padding: 20px;
        border-radius: 5px;
        display: inline-block;
        width: 500px;
        margin: 30px 100px;
        background-color: coral;
    }
    span{
        font-weight: 700;
    }
</style>
<body>
    <h1>Prototypes</h1>
    
    <p>Весь замысел прототипов состоит в том, чтобы вынести повторяющиеся св-ва и методы
        в некий прородительский класс, от которого будут наследоваться остальные классы. Отсюда вывод
        что это возможно лишь благодаря наследованию. Если в классическом программировании наследование 
        происходит от класса к классу, то в JS наследование происходит от объекта к объекту, поскольку 
        все в JS в конечном счете объект.
    </p>
    <p>
        Есть объект и есть прототип. сначала JS ищет св-ва или методы внутри самого объекта, если не находи
        то ищет в прототипе, и только если не находит там - выдает ошибку.
    </p>

    <code>
        Под капотом: 
        myObject.prototype = smartObject
        <br>
        Синтаксический сахар ES6:
        myObject extends smartObject
    </code>
    <pre>
        function Animal(name, age, weight){
            this.name = name
            this.age = age
            this.weight = weight
            this.getVoice = function(){
                console.log(this.name, this.age, this.weight)
            }
            this.eat = function(){
                this.weight++
            }
        }
        let a1 = new Animal(...)
        let a2 = new Animal(...)
    </pre>
    <p>
        В примере выше, у каждого instance объекта Animal будут повторятся все его св-ва и методы.
        Но, так как св-ва меняются а методы нет, то логично было бы вынести методы в "прородителя", в прототип.
        см. ниже
    </p>
    <pre>
        function Human(name, age, weight){
            this.name = name
            this.age = age
            this.weight = weight
        
        }
        Human.prototype.getVoice = function(){
            console.log(this.name, this.age, this.weight)
        }
        Human.prototype.eat = function(){
            this.weight++
        }
        
        let Igor = new Human('Igor', 33, 90)
    </pre>
    <p>
        Теперь каждый instance объекта Human будет иметь только св-ва характерные именно для этого
        человека, а методы убраны в прототип. Теперь мы не дублируем методы каждый раз.
    </p>





    <script src="./Explanations/prototype.js"></script>

</body>
</html>